
Scrap_by_Code_data 
        -> 
    module id with open circuit
            ->
        split wafer_id / die_#
```python
|>  probe_dir |> S:\Process Documentation\
        |>  wafer_dir |> Gen 3.5 x 128CH Doc\
              |>  wafer_folder |> 254367\
                  |>   CAP_folder |> Cap Data\
                       |>   probe_test_files \254367-R2-100.xls (find the latest)
```        


```python
# for instance, CAP data folder consists of two files
#     253634-40 and ACP 253634-40xls
#     there are two different acp measurement results.
#     this script keeps the latest one.
import pandas as pd
from functools import reduce
import glob
import os
import numpy as np
from IPython.display import display
# create 480x640 zeros
#           np.zeros((480, 640)) 
####################################################
##### err_msg -> df_error                   ########
##### err_dict -> id : [dies]               ########
##### lookup_cap_files -> id : cap_file_dir ########
####################################################
# df = pd.read_excel('excel_file_path.xls')
# this will read the first sheet into df
error_file = r"R:\Personal Folders\Jiacheng Qu\5_acp_probe_D128\Scrap_by_Code_data.xlsx"
err_msg = pd.read_excel(error_file)
print(err_msg.shape)
# ValueError: iAt based indexing can only have integer indexers
# print(err_msg.iat["Module Number"])

# x, y =(a, b for a, b in err_msg["Module Number"].split('-'))
module_list = err_msg["Module Number"]
module_num_pair = [a.split('-') for a in err_msg["Module Number"]]
print("module_num_pair: \n", module_num_pair)
err_dict = {}
for wafer, die in module_num_pair:
    if wafer not in err_dict:
        err_dict[wafer] = [die]
    else:
        err_dict[wafer] += [die]
print()
print(err_dict, "haha")
# print(err_msg["Module Number"].split('-'))

# ord_files = glob.glob(r"S:\Process Documentation\Gen 3.5 x 128CH Doc"
#                   + '/**/*.*', recursive=True)

# |>  probe_dir |>   wafer_dir |> wafer_folder   |>   CAP_folder   |> probe_test_files (find the latest)
# S: \\probe_dir \\wafer_folder \\CAP_folder \\probe_test_files.xls
#         lookup_cap_files -> dict{} += id : cap_file_dir
probe_dir = r"S:\Process Documentation\Gen 3.5 x 128CH Doc"
probe_files = glob.glob(probe_dir + '/*', recursive=False)
lookup_cap_files = {} 
for wafer_id, die_num in module_num_pair:
    if wafer_id not in lookup_cap_files:
        for wafer_dir in probe_files:
            if wafer_id in wafer_dir:
                wafer_folder = glob.glob(wafer_dir + "/*", recursive=False)
                for folder in wafer_folder:
                    if "CAP" in folder.upper():
                        cap_files = glob.glob(folder + "/*", recursive=False)
                        latest_file = max(cap_files, key=os.path.getctime)
                        lookup_cap_files[wafer_id] = latest_file
print("\n" + "\n".join(list(lookup_cap_files.values())))
```

    (15, 57)
    module_num_pair: 
     [['253634', '04'], ['253363', '23'], ['253037', '63'], ['253634', '35'], ['253634', '55'], ['253363', '39'], ['253037', '05'], ['253634', '43'], ['253363', '29'], ['254368', '63'], ['254367', '23'], ['254367', '25'], ['253634', '38'], ['253634', '40'], ['253634', '09']]
    
    {'253634': ['04', '35', '55', '43', '38', '40', '09'], '253363': ['23', '39', '29'], '253037': ['63', '05'], '254368': ['63'], '254367': ['23', '25']} haha
    
    S:\Process Documentation\Gen 3.5 x 128CH Doc\253634\Cap Data\253634-R2-100.xls
    S:\Process Documentation\Gen 3.5 x 128CH Doc\253363\Cap Data\253363-R2-100.xls
    S:\Process Documentation\Gen 3.5 x 128CH Doc\253037\Cap Data\253037-R3-100.xls
    S:\Process Documentation\Gen 3.5 x 128CH Doc\254368\Cap Data\254368-R2-100.xls
    S:\Process Documentation\Gen 3.5 x 128CH Doc\254367\Cap Data\254367-R2-100.xls
    


```python
# pop up the MODULE_NUMBER for each defective die #            
cols = list(err_msg) 
cols.insert(0, cols.pop(cols.index('Module Number'))) 
err_msg = err_msg.loc[:, cols] 
total_defect = err_msg.shape[0]
print(total_defect)
err_msg['Module Number']
```

    15
    




    0     253634-04
    1     253363-23
    2     253037-63
    3     253634-35
    4     253634-55
    5     253363-39
    6     253037-05
    7     253634-43
    8     253363-29
    9     254368-63
    10    254367-23
    11    254367-25
    12    253634-38
    13    253634-40
    14    253634-09
    Name: Module Number, dtype: object




```
sheet_to_df_map = pd.read_excel(file_name, sheet_name=None)
sheet_to_df_map
// this is no good for the data collecting purpose since read_excel sheet_name ==none
// only gives us Collections 
OrderedDict([('Die # 1 to 20',
                Date/Time:              2018-11-25 08:28:00       File Rev:  \
                Wafer Number:                        253634-R2      Jet Pitch:   
                Die Number:                                1    Die per Row:   
                WaferType:  Gen 128 Wafer    (128 Channels)       Channels:   
                Columns per Wafer:                                1  Die per Sheet:   
                Channel Number                          Cs (pf)             ESR   
                         1                          290.349         30.6914   
                         2                          287.298         31.4015   
                         3                          287.622         31.0717   
                         4                          286.934          31.436   
              
 [['253037', '05'],
 ['253037', '63'], 
 ['253363', '23'], 
 ['253363', '29'],
 ['253363', '39'], 
 ['253634', '04'], 
 ['253634', '09'],
 ['253634', '35'], 
 ['253634', '38'], 
 ['253634', '40'], 
 ['253634', '43'], 
 ['253634', '55'], 
 ['254367', '23'], 
 ['254367', '25'], 
 ['254368', '63']]
 ```


```python
# find the whole list of post_test results
#      dir_year -> id_folder -> results_acp_mvd.xls
def list_acp_results(year, w_id, d_no) -> list:
    year, w_id, d_no = str(year), str(w_id), str(d_no)
    dir_year = str(r"S:\128-G3pt6_Module-project\Cap test\\" + year) 
    id_folders = glob.glob( dir_year + '/*', recursive=False)
    list_test = []
    header = []
    for folder in id_folders:
        if w_id in folder: # 
            module_num = w_id + "-" + d_no 
            dir_pl = str(folder + r"year") 
            acp_files_by_die = glob.glob( folder + '/*', recursive=False)
            for acp in acp_files_by_die:
                if module_num in acp: 
                    temp_acp = acp.split("\\")[-1]
                    temp_acp = temp_acp[:-8]
                    temp_acp = ''.join([i for i in temp_acp if i.isalpha()])
                    temp_acp = temp_acp[:10]
                    if temp_acp not in header: 
                        header += [temp_acp.upper()]
                        list_test += [acp]
                    else: 
                        coor = header.index(temp_acp)
                        list_test[coor] = max([acp, list_test[coor]], key=os.path.getctime)
            break # if found a w_id match then break the folder looping  
    dict_t = {k:v for k, v in zip(header, list_test)} 
    return dict_t 
```


```python
# find the whole list of acp&mvd results
#      dir_year -> id_folder -> results_acp_mvd.xls
def list_head_results(year, w_id, d_no) -> list:
    year, w_id, d_no = str(year), str(w_id), str(d_no)
    dir_year = str(r"S:\128-G3pt6_Module-project\Cap test\\" + year) 
    id_folders = glob.glob( dir_year + '/*', recursive=False)
    list_test = []
    header = []
    for folder in id_folders:
        if w_id in folder: # 
            module_num = w_id + "-" + d_no 
            dir_pl = str(folder + r"\year") 
            acp_files_by_die = glob.glob( folder + '/*', recursive=False)
            for acp in acp_files_by_die:
                if module_num in acp:
                    temp_acp = acp.split("\\")[-1]
                    temp_acp = temp_acp[:-8]
                    temp_acp = ''.join([i for i in temp_acp if i.isalpha()])
                    temp_acp = temp_acp[:10]
                    if temp_acp not in header: 
                        header += [temp_acp.upper()]
                        list_test += [acp] 
            break # if found a w_id match then break the folder looping 
    head_0 = set(header) 

    return head_0
```


```python
# init_df: np.NaN.np.empty((row, col))
# create the table with NaN values
head_col_name = set() 
for wafer_id, cap_file in lookup_cap_files.items():
    xls = pd.ExcelFile(cap_file) 
    sheet_to_df_map = pd.read_excel(
        cap_file, sheet_name=None, header=None)  #,index_col=0
    df1 = pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[0]])
    df1 = df1.append(
        pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[1]]),
        ignore_index=True)
    df1 = df1.append(
        pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[2]]),
        ignore_index=True) 
    die_0 = df1.index[df1[0] == 'Die Number:'].tolist()
    index_1 = df1.index[df1[0] == 1].tolist()
    index_128 = df1.index[df1[0] == 128].tolist() 
    list_1to128 = []
    if len(die_0) == 70 and len(index_1) == 70 and len(index_128) == 70:
        die_list_1 = []
        die_list_128 = []  
        a, b = [], []
        for die in err_dict[wafer_id]: 
            head_col_name = head_col_name | list_head_results(2019, wafer_id, die)
            head_col_name = head_col_name | list_head_results(2018, wafer_id, die) 
    else:
        raise Exception('there are only %d %d %d dies, check the cap files: %s'\
                        % (len(die_0), len(index_1), len(index_128), cap_file)) 
init_df_col_0 = ["Probe"] + sorted(list(head_col_name))
print(init_df_col_0) 
two_layer_col = [init_df_col_0, ['Cp_pF','ESR_ohm','PZTLeak_V']]
index = pd.MultiIndex.from_product(two_layer_col)  
col_num = len(init_df_col_0) * 3 
row_num = total_defect * 128 
init_df = pd.DataFrame(np.NaN*np.empty((row_num, col_num)), columns=index) 
init_df["Probe","Bv_V"] = init_df["Probe","PZTLeak_V"]
init_df.drop(("Probe","PZTLeak_V"), axis = 1, inplace = True) 
init_df = init_df.sort_index(level=0, axis=1)
 
display(init_df.head())
 
print((init_df.shape)) 
print([x for x in list(init_df)])
```

    ['Probe', 'ACP', 'AFTERFACEP', 'AFTERMVD', 'CLEAN', 'FACEPLATE', 'FINAL', 'POSTCLEAN', 'POSTMVDPRE', 'PRECLEAN']
    


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">ACP</th>
      <th colspan="3" halign="left">AFTERFACEP</th>
      <th colspan="3" halign="left">AFTERMVD</th>
      <th>CLEAN</th>
      <th>...</th>
      <th>POSTCLEAN</th>
      <th colspan="3" halign="left">POSTMVDPRE</th>
      <th colspan="3" halign="left">PRECLEAN</th>
      <th colspan="3" halign="left">Probe</th>
    </tr>
    <tr>
      <th></th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>...</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Bv_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 30 columns</p>
</div>


    (1920, 30)
    [('ACP', 'Cp_pF'), ('ACP', 'ESR_ohm'), ('ACP', 'PZTLeak_V'), ('AFTERFACEP', 'Cp_pF'), ('AFTERFACEP', 'ESR_ohm'), ('AFTERFACEP', 'PZTLeak_V'), ('AFTERMVD', 'Cp_pF'), ('AFTERMVD', 'ESR_ohm'), ('AFTERMVD', 'PZTLeak_V'), ('CLEAN', 'Cp_pF'), ('CLEAN', 'ESR_ohm'), ('CLEAN', 'PZTLeak_V'), ('FACEPLATE', 'Cp_pF'), ('FACEPLATE', 'ESR_ohm'), ('FACEPLATE', 'PZTLeak_V'), ('FINAL', 'Cp_pF'), ('FINAL', 'ESR_ohm'), ('FINAL', 'PZTLeak_V'), ('POSTCLEAN', 'Cp_pF'), ('POSTCLEAN', 'ESR_ohm'), ('POSTCLEAN', 'PZTLeak_V'), ('POSTMVDPRE', 'Cp_pF'), ('POSTMVDPRE', 'ESR_ohm'), ('POSTMVDPRE', 'PZTLeak_V'), ('PRECLEAN', 'Cp_pF'), ('PRECLEAN', 'ESR_ohm'), ('PRECLEAN', 'PZTLeak_V'), ('Probe', 'Bv_V'), ('Probe', 'Cp_pF'), ('Probe', 'ESR_ohm')]
    


```python
def update_summary_table(in):
    df.loc[df.A==0, 'B'] = np.nan
```


```python
######   following will load probe data and drop the good ones   ######
#####          err_msg -> df_error                             ########
#####          err_dict -> id : [dies]                         ########
#####          lookup_cap_files -> id : cap_file_dir           ########
#######################################################################
# LINE 7  will read all sheets into orderDict, access by list(.keys())[index]
# init_df from above
wafer_col = []  # n = (defective_die_count * 128) for each wafer
die_col = []    # n = (defective_die_count * 128) for each wafer
new_df = pd.DataFrame()
result_dict = {} # dict -> wafer_die : [files]
for wafer_id, cap_file in lookup_cap_files.items():
    xls = pd.ExcelFile(cap_file)
    # Now you can list all sheets in the file
    #     print("\nxls.sheet_names: \n", xls.sheet_names)
    
    #    #    #    #    #    #    #    #    #    #    #     
    # 1  #  append 3 sheets and get 70 dies in the same sheet    
    #    #    #    #    #    #    #    #    #    #    #    
    sheet_to_df_map = pd.read_excel(
        cap_file, sheet_name=None, header=None)  #,index_col=0
    df1 = pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[0]])
    df1 = df1.append(
        pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[1]]),
        ignore_index=True)
    df1 = df1.append(
        pd.DataFrame(sheet_to_df_map[list(sheet_to_df_map.keys())[2]]),
        ignore_index=True)
    print(df1.shape)
    
    #    #    #    #    #    #    #    #    #    #    #    
    # 2  #  locate the start:end (1:128s) row number  of each die 
    #    #    #    #    #    #    #    #    #    #    #    
    die_0 = df1.index[df1[0] == 'Die Number:'].tolist()
    index_1 = df1.index[df1[0] == 1].tolist()
    index_128 = df1.index[df1[0] == 128].tolist()
    
    #    #    #    #    #    #    #    #    #    #    #    
    # 2.1 #  locate the start:end (1:128s) row number  of each die 
    #    #    #    #    #    #    #    #    #    #    #    
    #    #   check if each index is correctly mapped x[128] - x[1] = 127    
    #  diff_128_1 = [x - y for x, y in zip(index_128, index_1)]     
    #  print(set(diff_128_1).pop() == 127)   # print(set(diff_128_1) == {127})
    #    #   check if there are 70 dies in total
    #    #   alter solution: reduce mode
    #  diff = reduce((lambda x, y: x + y), diff_128_1) / 70    #     print(diff == 128 - 1)
    print()
    
    #    #    #    #    #    #    #    #    #    #    #     
    # 3  #  for each wafer drop the good dies' 1:128 ~ (list: 1 to 128)
    #       and append the defectives to new_dataframe
    #    #    #    #    #    #    #    #    #    #    #    
    list_1to128 = []
    if len(die_0) == 70 and len(index_1) == 70 and len(index_128) == 70:
        die_list_1 = []
        die_list_128 = []
        print(wafer_id, err_dict[wafer_id])
        wafer_col += [wafer_id] * len(err_dict[wafer_id]) * 128
        a, b = [], [] 
        for die in err_dict[wafer_id]: 
            temp = list_acp_results(2019, wafer_id, die)
            mod_num = wafer_id + "-" + die
            if temp:
                result_dict[mod_num] = temp
            else:
                result_dict[mod_num] = list_acp_results(2018, wafer_id, die)
            if not result_dict[mod_num]:
                result_dict[mod_num] = list_acp_results(2017, wafer_id, die) 
            die_num = int(die)
            die_col += [die] * 128
            die_list_1 += [index_1[die_num - 1]]
            die_list_128 += [index_128[die_num - 1]] 
        print("a:b ", len(a), len(b))
        for i1, i128 in zip(die_list_1, die_list_128):
            num128 = list(range(i1, i128 + 1))
            list_1to128.extend(num128)
        to_drop = list(set(range(df1.shape[0])) - set(list_1to128)) 
        new_df_0 = df1.drop(to_drop)
        new_df = new_df.append(new_df_0) 
    else:
        raise Exception('there are only %d %d %d dies, check the cap files: %s'\
                        % (len(die_0), len(index_1), len(index_128), cap_file))
    print() 

# drop columns from the probe data
new_df = new_df.reset_index(drop=True)
new_df = new_df.drop(columns=[3,5,6,7])

#    #    #    #    #    #    #    #    #    #    #     
# 4  #  sort the probe result
#       and append and update the big df with probe_data and module_list  
#       ["Probe","Cp_pF"] ["Probe","ESR_ohm"] ["Probe","Bv_V"]  
#       ["Module","Module_Die"] ["Module","wafer_col"] ["Module","die_col"] ["Module","Channel"]
#    #    #    #    #    #    #    #    #    #    #    
new_df.rename(
    columns={
        0: 'Channel',
        1: 'Cp_pF',
        2: 'ESR_ohm',
        4: 'Bv_V'
    }, inplace=True)
# # new_df.drop([3,5,6,7], axis=1)
display(new_df.head())
# replace init_df with new_df (probe data) 
init_df["Probe","Bv_V"] = new_df["Bv_V"] 
init_df["Probe","Cp_pF"] = new_df["Cp_pF"] 
init_df["Probe","ESR_ohm"] =  new_df["ESR_ohm"] 
init_df["Module","Channel"] = list(new_df["Channel"]) 
init_df["Module","wafer_col"] = list(wafer_col)
init_df["Module","die_col"] = die_col
init_df["Module","Module_Die"] = [str(x) + "-" + str(y) for x, y in zip(wafer_col, die_col)] 
cols = list(init_df) 
cols.insert(0, cols.pop(cols.index(("Module","Channel"))))
cols.insert(0, cols.pop(cols.index(("Module","die_col"))))
cols.insert(0, cols.pop(cols.index(("Module","wafer_col"))))
cols.insert(0, cols.pop(cols.index(("Module","Module_Die"))))

# use  .reindex[] to swap the column order
init_df = init_df.reindex(columns=pd.MultiIndex.from_tuples(cols))
init_df = init_df.sort_values(by=[("Module","Module_Die"),("Module","Channel")],ascending=True)
init_df = init_df.reset_index(drop=True)
display(init_df.head())
list(result_dict.items()) 
# new_df = new_df[cols]
# init_df.to_csv(r'R:\Personal Folders\Jiacheng Qu\5_acp_pro' +\
#             r'be_D128\fetched_probe_data\Test_of_5_opens_whole.csv', sep=';', index=False) 
```

    (9514, 8)
    
    253634 ['04', '35', '55', '43', '38', '40', '09']
    a:b  0 0
    
    (9514, 8)
    
    253363 ['23', '39', '29']
    a:b  0 0
    
    (9514, 8)
    
    253037 ['63', '05']
    a:b  0 0
    
    (9514, 8)
    
    254368 ['63']
    a:b  0 0
    
    (9514, 8)
    
    254367 ['23', '25']
    a:b  0 0
    
    


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Channel</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>Bv_V</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>290.31</td>
      <td>30.4809</td>
      <td>43.539</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>287.995</td>
      <td>31.0988</td>
      <td>43.539</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>288.8</td>
      <td>30.7468</td>
      <td>43.539</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>287.764</td>
      <td>31.1896</td>
      <td>43.539</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>287.044</td>
      <td>31.0161</td>
      <td>43.539</td>
    </tr>
  </tbody>
</table>
</div>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="4" halign="left">Module</th>
      <th colspan="3" halign="left">ACP</th>
      <th colspan="3" halign="left">AFTERFACEP</th>
      <th>...</th>
      <th>POSTCLEAN</th>
      <th colspan="3" halign="left">POSTMVDPRE</th>
      <th colspan="3" halign="left">PRECLEAN</th>
      <th colspan="3" halign="left">Probe</th>
    </tr>
    <tr>
      <th></th>
      <th>Module_Die</th>
      <th>wafer_col</th>
      <th>die_col</th>
      <th>Channel</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>...</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
      <th>PZTLeak_V</th>
      <th>Bv_V</th>
      <th>Cp_pF</th>
      <th>ESR_ohm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>253037-05</td>
      <td>253037</td>
      <td>05</td>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>43.55</td>
      <td>320.99</td>
      <td>27.5889</td>
    </tr>
    <tr>
      <th>1</th>
      <td>253037-05</td>
      <td>253037</td>
      <td>05</td>
      <td>2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>43.55</td>
      <td>320.469</td>
      <td>27.8052</td>
    </tr>
    <tr>
      <th>2</th>
      <td>253037-05</td>
      <td>253037</td>
      <td>05</td>
      <td>3</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>43.55</td>
      <td>320.069</td>
      <td>27.8286</td>
    </tr>
    <tr>
      <th>3</th>
      <td>253037-05</td>
      <td>253037</td>
      <td>05</td>
      <td>4</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>43.55</td>
      <td>319.492</td>
      <td>27.8066</td>
    </tr>
    <tr>
      <th>4</th>
      <td>253037-05</td>
      <td>253037</td>
      <td>05</td>
      <td>5</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>43.55</td>
      <td>318.337</td>
      <td>27.9759</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 34 columns</p>
</div>





    [('253634-04',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-04.xls'}),
     ('253634-35',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-35.xls'}),
     ('253634-55',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-55.xls'}),
     ('253634-43',
      {'FACEPLATE': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Face Plate 253634-43 xls.xls'}),
     ('253634-38',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-38.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\After MVD  253634-38  xls.xls',
       'FACEPLATE': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Face Plate 253634-38 xls.xls',
       'POSTCLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\post clean 253634-38.xls',
       'PRECLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\pre-clean 253634-38.xls'}),
     ('253634-40',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-40xls.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\After MVD  253634-40 xls.xls',
       'FACEPLATE': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Face Plate 253634-40 xls.xls',
       'POSTCLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\post clean 253634-40.xls',
       'PRECLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\pre-clean 253634-40.xls'}),
     ('253634-09',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\ACP 253634-09.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\After MVD  253634-09 xls.xls',
       'CLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\clean 1 253634-09.xls',
       'FACEPLATE': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Face Plate 253634-09 xls.xls',
       'FINAL': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Final 253634-09.xls',
       'POSTMVDPRE': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\Post MVD Prebake 253634-09 xls.xls',
       'PRECLEAN': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253634-1pl\\pre-clean 253634-09.xls'}),
     ('253363-23',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253363-1pl\\ACP 253363-23xls.xls'}),
     ('253363-39',
      {'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253363-1pl\\After Faceplate 253363-39xls.xls'}),
     ('253363-29',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253363-1pl\\ACP 253363-29xls.xls',
       'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253363-1pl\\After Faceplate 253363-29xls.xls'}),
     ('253037-63',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253037- 1pl\\ACP 253037-63.xls'}),
     ('253037-05',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253037- 1pl\\ACP 253037-05.xls',
       'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\253037- 1pl\\After Face plate 253037-05.xls'}),
     ('254368-63',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2018\\254368 - 1pl\\ACP 254368-63.xls',
       'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2018\\254368 - 1pl\\After Face plate 254368-63.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2018\\254368 - 1pl\\After MVD 254368-63 xls.xls'}),
     ('254367-23',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\ACP 254367-23.xls',
       'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\After Face plate 254367-23.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\After MVD 254367-23. xls.xls'}),
     ('254367-25',
      {'ACP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\ACP 254367-25.xls',
       'AFTERFACEP': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\After Face plate 254367-25.xls',
       'AFTERMVD': 'S:\\128-G3pt6_Module-project\\Cap test\\\\2019\\254367-1pl\\After MVD 254367-25. xls.xls'})]




```python
temp = pd.DataFrame()

# head_col_name = ['ACP', 'AFTERFACEP', 'AFTERMVD', 'CLEAN', 'FACEPLATE', 
#                  'FINAL', 'POSTCLEAN', 'POSTMVDPRE', 'PRECLEAN']
print(head_col_name)
for module in sorted(result_dict.keys()):
    for header in sorted(result_dict[module].keys()):
#         result_dict[module][header] -> values
    
    
    
```


      File "<ipython-input-7-82b7902b9a0c>", line 11
        
        ^
    SyntaxError: unexpected EOF while parsing
    



```python

```


```python
d1 = str(r"S:\128-G3pt6_Module-project\Cap test\2019\\") 
i2 = glob.glob( d1 + '/**/*.xls', recursive=True)

for xls_file in i2:
    temp = xls_file.split(sep="\\")
    print(temp[-1]) 
    print(''.join([i.upper() for i in temp[-1][:-4] if i.isalpha()]))

    
```


```python
df.loc[df['column_name'] == some_value]
```


```python
error_map = pd.read_csv(
    r"C:\Users\jiacheng.qu\Documents\command line\Python Scripts\D128\Scrap_by_Code_data.xlsx"
                       )
error_map.head()
```


```python

```
